'use strict';
const front_utils = function() {


    /**
     * Converts a string into an HTMLElement.
     * @param {string} str - The string to convert.
     * @returns {HTMLElement}
     */
    function string_to_html(str) {
    	const div = document.createElement('div');
    	div.innerHTML = str;
        const element = div.firstElementChild;
        return element;
    }




    function get_closest_parent(elem, selector) {
        // From here: https://gomakethings.com/how-to-get-the-closest-parent-element-with-a-matching-selector-using-vanilla-javascript/
    	// Element.matches() polyfill
    	if (!Element.prototype.matches) {
    	    Element.prototype.matches =
    	        Element.prototype.matchesSelector ||
    	        Element.prototype.mozMatchesSelector ||
    	        Element.prototype.msMatchesSelector ||
    	        Element.prototype.oMatchesSelector ||
    	        Element.prototype.webkitMatchesSelector ||
    	        function(s) {
    	            const matches = (this.document || this.ownerDocument).querySelectorAll(s),
    	                i = matches.length;
    	            while (--i >= 0 && matches.item(i) !== this) {}
    	            return i > -1;
    	        };
    	}

    	// Get the closest matching element
    	for ( ; elem && elem !== document; elem = elem.parentNode ) {
    		if ( elem.matches( selector ) ) return elem;
    	}
    	return null;
    };




    function required_arg(arg=undefined) {
        const error = new Error(`Required argument missing (${arg})`);
        if (Error.captureStackTrace)
        {
            Error.captureStackTrace(error, required_arg);
        }
        throw error;
    }




    function render(template, context, make_obj) {
        let element = template(context);
        if (make_obj) {
            element = string_to_html(element);
        }
        return element;
    }




    /**
     * Used to get/parse content of script tag generated by Django's built-in
     * `json_script` template tag. Of course, it's really just a one-liner
     * to achieve the desired result, however this comes with a few benefits
     * where this would throw an error if the element is not found or if
     * something looks wrong with the element found.
     */
    function get_json_script_value(element_id) {
        const element = document.getElementById(element_id);
        if (! element) {
            throw new ElementNotFound(element_id);
        }
        const json_type = 'application/json';
        if (element.type !== json_type) {
            throw new Error(
                `JSON script must have type attribute of "${json_type}"`
            );
        }
        const value = JSON.parse(element.textContent);
        return value;
    }




    // Copied from Underscore.js
    // Returns a function, that, as long as it continues to be invoked, will not
    // be triggered. The function will be called after it stops being called for
    // N milliseconds. If `immediate` is passed, trigger the function on the
    // leading edge, instead of the trailing.
    function debounce(func, wait, immediate) {
        let timeout;
        return function() {
            const context = this;
            const args = arguments;
            const later = function() {
                timeout = null;
                if (! immediate) {
                    func.apply(context, args);
                }
            };
            const callNow = immediate && !timeout;
            clearTimeout(timeout);
            timeout = setTimeout(later, wait);
            if (callNow) {
                func.apply(context, args);
            }
        };
    }




    async function stall(stall_time=3000) {
        await new Promise(resolve => setTimeout(resolve, stall_time));
    }




    function insert_after(reference_node, new_node) {
        reference_node.parentNode.insertBefore(
            new_node, reference_node.nextSibling
        );
    }




    function remove_from_array(array, value) {
        const index = array.indexOf(value);
        if (index > -1) {
            array.splice(index, 1);
        }
    }




    function format_date(value) {
        let options = { year: 'numeric', month: 'long', day: 'numeric' };
        let date = new Date(value);
        return new Intl.DateTimeFormat('en-US', options).format(date);
    }




    function format_time(value) {
        let date = new Date(value);
        let hours = date.getHours();
        let minutes = date.getMinutes();
        let seconds = date.getSeconds();

        // Pad single digit hour/minute values with leading zeros
        hours = hours < 10 ? '0' + hours : hours;
        minutes = minutes < 10 ? '0' + minutes : minutes;
        seconds = seconds < 10 ? '0' + seconds : seconds;
        return `${hours}:${minutes}:${seconds}`;
    }




    function format_datetime(value) {
        const date = format_date(value);
        const time = format_time(value);
        return `${date} ${time}`;
    }



    function capitalize(value) {
        value = value.charAt(0).toUpperCase() + value.slice(1);
        return value
    }



    function capfirst() {
        return capitalize();
    }




    return {
        string_to_html: string_to_html,
        get_closest_parent: get_closest_parent,
        required_arg: required_arg,
        render: render,
        debounce: debounce,
        stall: stall,
        get_json_script_value: get_json_script_value,
        insert_after: insert_after,
        remove_from_array: remove_from_array,

        capitalize: capitalize,
        capfirst: capfirst,

        format_date: format_date,
        format_time: format_time,
        format_datetime: format_datetime,
    };
}();
